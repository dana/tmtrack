from flask import Blueprint, request, jsonify
from uuid import uuid4
import datetime
from ..services.mongo_service import MongoService

tasks_bp = Blueprint('tasks', __name__)
mongo_service = MongoService()

# Define required and optional fields with their types
TASK_FIELDS = {
    "task_id": {"type": str, "required": True}, # Synthetic UUID, generated by API
    "userid": {"type": str, "required": True},
    "date": {"type": str, "required": True}, # YYYY-MM-DD
    "task_name": {"type": str, "required": True},
    "category": {"type": str, "required": True},
    "expected_hours": {"type": float, "required": True},
    "actual_hours": {"type": float, "required": False},
    "description": {"type": str, "required": False}
}

# --- FIX: Define internal fields to be ignored by arbitrary attribute validation ---
INTERNAL_FIELDS = {'created_at', 'updated_at'} # Using a set for faster lookups


def validate_task_data(data, is_create=True):
    # ... (This function does not need to be changed)
    """
    Validates incoming data against predefined TASK_FIELDS.
    If is_create is True, all required fields must be present.
    If is_create is False, only fields present in data are validated.
    """
    errors = {}

    for field, specs in TASK_FIELDS.items():
        if is_create and specs["required"] and field not in data:
            if field != "task_id": # task_id is generated, not provided by user on create
                errors[field] = f"'{field}' is a required field."
            continue # Don't validate type if field is missing for create

        if field in data:
            value = data[field]
            expected_type = specs["type"]
            if not isinstance(value, expected_type):
                errors[field] = f"'{field}' must be of type {expected_type.__name__}, but got {type(value).__name__}."

            # Specific date format validation
            if field == "date" and expected_type == str:
                try:
                    datetime.datetime.strptime(value, '%Y-%m-%d')
                except ValueError:
                    errors[field] = f"'{field}' must be in YYYY-MM-DD format."

    # For modify, check if task_id is present if it's the only field
    if not is_create and "task_id" not in data:
        errors["task_id"] = "'task_id' is required for modification."

    return errors


@tasks_bp.route('/tasks', methods=['POST'])
def create_task():
    """
    Creates a new task document in MongoDB.
    Generates a unique task_id.
    Validates all required and optional fields.
    Allows arbitrary additional string attributes.
    """
    data = request.get_json()
    if not data:
        return jsonify({"status": "error", "message": "Request must be JSON"}), 400

    validation_errors = validate_task_data(data, is_create=True)
    if validation_errors:
        return jsonify({"status": "error", "message": "Validation failed", "errors": validation_errors}), 400

    # Generate synthetic UUID for task_id
    task_id = str(uuid4())
    data['task_id'] = task_id

    # Add creation timestamp
    data['created_at'] = datetime.datetime.now(datetime.timezone.utc)
    data['updated_at'] = datetime.datetime.now(datetime.timezone.utc)

    # --- FIX: Modify the validation loop to ignore internal fields ---
    # Ensure all arbitrary additional attributes are strings if provided
    for key, value in data.items():
        # An attribute is arbitrary if it's not a defined task field AND not an internal field
        if key not in TASK_FIELDS and key not in INTERNAL_FIELDS and not isinstance(value, str):
            return jsonify({"status": "error", "message": f"Arbitrary attribute '{key}' must be a string."}), 400

    try:
        mongo_service.insert_task(data)
        return jsonify({
            "status": "success",
            "message": "Task created successfully",
            "task_id": task_id
        }), 201
    except Exception as e:
        return jsonify({"status": "error", "message": f"Failed to create task: {str(e)}"}), 500


@tasks_bp.route('/tasks/<string:task_id>', methods=['PUT'])
def modify_task(task_id):
    """
    Modifies an existing task document in MongoDB.
    The task_id in the URL defines which document to modify.
    Only provided fields will be updated.
    Performs type checking on provided fields.
    """
    data = request.get_json()
    if not data:
        return jsonify({"status": "error", "message": "Request must be JSON"}), 400

    if 'task_id' in data:
        del data['task_id']

    validation_errors = validate_task_data(data, is_create=False)
    if validation_errors:
        return jsonify({"status": "error", "message": "Validation failed", "errors": validation_errors}), 400

    # Add update timestamp
    data['updated_at'] = datetime.datetime.now(datetime.timezone.utc)

    # --- FIX: Modify the validation loop to ignore internal fields ---
    # Ensure all arbitrary additional attributes are strings if provided
    for key, value in data.items():
        # An attribute is arbitrary if it's not a defined task field AND not an internal field
        if key not in TASK_FIELDS and key not in INTERNAL_FIELDS and not isinstance(value, str):
            return jsonify({"status": "error", "message": f"Arbitrary attribute '{key}' must be a string."}), 400

    try:
        modified_count = mongo_service.update_task(task_id, data)
        if modified_count == 0:
            return jsonify({
                "status": "error",
                "message": f"Task with task_id '{task_id}' not found or no changes made."
            }), 404
        return jsonify({
            "status": "success",
            "message": "Task updated successfully",
            "task_id": task_id
        }), 200
    except Exception as e:
        return jsonify({"status": "error", "message": f"Failed to update task: {str(e)}"}), 500

# Optionally, add a GET endpoint for debugging/testing
@tasks_bp.route('/tasks/<string:task_id>', methods=['GET'])
def get_task(task_id):
    """Retrieves a single task by its task_id."""
    try:
        task = mongo_service.get_task(task_id)
        if task:
            # Convert ObjectId to string for JSON serialization
            if '_id' in task:
                task['_id'] = str(task['_id'])
            return jsonify({"status": "success", "task": task}), 200
        return jsonify({"status": "error", "message": "Task not found"}), 404
    except Exception as e:
        return jsonify({"status": "error", "message": f"Failed to retrieve task: {str(e)}"}), 500

# Optionally, add a GET endpoint for listing tasks
@tasks_bp.route('/tasks', methods=['GET'])
def get_all_tasks():
    """Retrieves all tasks."""
    try:
        tasks = mongo_service.get_all_tasks()
        # Convert ObjectId to string for JSON serialization
        for task in tasks:
            if '_id' in task:
                task['_id'] = str(task['_id'])
        return jsonify({"status": "success", "tasks": tasks}), 200
    except Exception as e:
        return jsonify({"status": "error", "message": f"Failed to retrieve tasks: {str(e)}"}), 500

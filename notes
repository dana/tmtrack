Mon 22 Sep 08:06:32 PDT 2025

Initial gemini prompt to create project that has a working tox test environment.

<background_context>

We are making a modern python, standards and PEP compliant flask based REST API that will connect to a localhost installed mongodb database.  This application is called "tmtrack", which means "time tracker".  Each mongodb document should represent a single task on a single day.  The mongodb document should contain at a minimum the following attributes:

* task_id : a required string that contains a synthetic UUID created upon document creation
* userid : a required string that contains the userid of the person doing the task
* date : the required calendar date on which the task is to be done
* task_name : a required string that is the name of the task
* category : a required string that is the category of the task
* expected_hours : a required float containing the number of hours the task is expected to take
* actual_hours : an optional float containing the number of hours the task actually took
* description : an optional large string that contains text allowing the user to add some context about this task

The unique, primary key for each document is task_id.

The initial REST API Flask calls are:

* Create a new task document that creates the previously a document with the previously defined attributes.  It will fail if any of the required attributes are missing, and also allow any optional attributes to be set at the same time.  It will allow any arbitrary additional attributes to be passed in by name and value, all of type string.  It will check all of the defined data types and fail if any of them are incorrect.  Prior to creating the document, create a string task_id that is also saved in the document and also returned by the REST API to the caller.

* Modify an existing task document.  This API call takes any number of arguments, but task_id is required and defines which document in the database is to be modified.  All of the other attributes passed into this API call over-write the values of the same named attributes in the mongodb document referenced by task_id.  The attributes should be type checked and the call should fail making no modifications if there are any errors, type checked or otherwise.

</background_context>


<create_project>

Please create this project as described above, including all of the necessary directory structure, configuration and support files.

Given all of this context, please select an appropriate mongodb database name and mongodb collection name for this project.

This should be fully testable by the 'tox' python framework.

Each API call should be testable and tested by command-line curl calls.

This is being built on Ubuntu 24.  Make sure what you produce passes all tests after a command-line 'tox' invocation.

This project will be hosted on github, please include all standard support and documentation files appropriate for a new github, modern python project.

</create_project>


Mon 22 Sep 08:36:26 PDT 2025
Ran the above background and create project prompts together, worked pretty well:
https://github.com/dana/tmtrack/commit/7dd8f6f598a7536f42bf85422fc1e1d4ce3e39c3

'tox' works.  I wanted the tests to actually hit a real mongodb database instead of mock objects.

Mon 22 Sep 09:03:20 PDT 2025
Second Gemini prompt.

<move_to_live_db_testing>
Our goal is to modify the above specified project such that the tests aren't mocked and run against a real, live, running mongodb database reachable on localhost on the standard port.

Please also modify the documentation detailing not only how to run the app on ubuntu 24 but also what command line steps are required to prepare the environment to run the app with standard 'flask run'.

</move_to_live_db_testing>

This is pretty good.  Tox still works, but there is an error when running it live.

I also changed the AI model from the default 'Nano Banana' to 'Gemini 2.5 Pro'

<fix_arbitrary_attribute_create_error>
Given the following command-line invocation, an error occurs:

$ curl -X POST -H "Content-Type: application/json" -d '{
    "userid": "curluser1",
    "date": "2023-10-27",
    "task_name": "Review documentation",
    "category": "Documentation",
    "expected_hours": 2.0,
    "description": "Review the updated README.md"
}' http://127.0.0.1:5000/api/v1/tasks
{"message":"Arbitrary attribute 'created_at' must be a string.","status":"error"}

Please make a test case to capture this error and also necessary code changes to fix it.

</fix_arbitrary_attribute_create_error>


Tue 23 Sep 07:25:20 PDT 2025
<fix_modify_error>
Given the following command-line invocation, an error occurs:

$ curl -X PUT -H "Content-Type: application/json" -d '{
    "actual_hours": 2.5,
    "notes": "Completed faster than expected."
}' http://127.0.0.1:5000/api/v1/tasks/c5845f36-c22a-499f-8c69-520545df75ce
{"errors":{"task_id":"'task_id' is required for modification."},"message":"Validation failed","status":"error"}

Please make a test case to capture this error and also make necessary code changes to fix it.  Note that it should not be required to pass "task_id" in as an attribute since it's already defined in the URL.
</fix_modify_error>

<fix-jquery-cors-runtime-error>
The following javascript error occured:

Access to XMLHttpRequest at 'http://localhost:5000/api/v1/tasks' from origin 'http://127.0.0.1:8000' has been blocked by CORS policy: No 'Access-Control-Allow-Origin' header is present on the requested resource.

What code changes are necessary to resolve this?
</fix-jquery-cors-runtime-error>


<multi-users-pt1>
Add a new REST route called list_users that returns an array of strings.
Each of these strings are a userid that is allowed to use this system.
The two userids to return are: "dana" and "michelle".

Please add a test for this route in the normal way.
</multi-users-pt1>

<categories>
We need a new REST route called categories.  A GET on the categories route
will return something like this:
 {
     "categories" : [
         "category1",
         "category2"
     ]
 }

This is to be stored in the mongodb collection called 'categories'.  This
collection should have a single document which is exactly what is returned
by the above GET.

In the same way, a PUT on the categories route will replace the entire,
single document with the value in the PUT request.  The PUT request will
have exactly the same document format as described above.

If it makes sense, put this route in a separate Python file.

Also add tests for this feature without any mock objects.  The test should
connect to and use the real MongoDB database.

Also add documentation as needed.
</categories>

<auth-and-authen-pt1>
For authentication, please produce a plain JSON file located where the
REST API server can read and parse it.  This file can be read only on
startup and its contents kept as a static data structure inside of the
REST API server.  The data structure can be called user_authentication and
the on-filesystem file called user_authentication.json, and contains a
mapping between userids and authentication tokens.  Start with the
following file contents:
 [  {   "userid": "dana",
        "auth_token": "730ea935edf1dd98eef8"
    },{
        "userid": "michelle",
        "auth_token": "330829f6cb0b17ff21f5"
    }
 ]

Please create a method that takes in the auth_token as a
single parameter and returns the associated userid.  If the passed
token is missing or doesn't exist in the data structure, then return
the string "guest".  This method needs to be easily callable
from anywhere in the REST API server.

Please add some relevant relevant tests and comprehensive documentation
for this change.


For authorization, please produce a plain JSON file located where the
REST API server can read and parse it.  This file can be read only on
startup and its contentws kept as a static data structure inside of the
REST API server.  The data structure can be called user_authorization and
the on-filesystem file called user_authorization.json, and contains a
mapping between userids and user groups.  Start with the following file
contents:
 [  {   "group_name": "Hunny Bunnies",
        "userids": ["dana", "michelle"]
    },{
        "group_name": "Administrators",
        "userids": ["dana"]
    },{
        "group_name": "Guests",
        "userids": ["guest"]
    }
 ]

Please create a method that takes in the userid as a single parameter
and returns the associate list of groups.  For example, given the above
data, if the userid "dana" is passed, the method should return the list
["Hunny Bunnies", "Administrators"]  If a userid that doesn't exist
is passed, return the list ["Guests"]  This method needs to be easily
callable from anywhere in the REST API server.

Please add some relevant relevant tests and comprehensive documentation
for this change.

Please provide the necessary changes, and display all changed or added files in full.
</auth-and-authen-pt1>

<auth-and-authen-pt2>
For every call to the REST API server, please examine the Authorization
header of the HTTP request.  This Authorization header might contain
an auth_token, as defined previously.  Please use the previously
created methods to convert the passed Authorization header into
the related userid and related group_names, as defined in the data structures
above.

Every one of the existing REST calls should be modified to ALSO return
a "userid" attribute and a "groups" attribute, in addition to everything
the existing call returns right now.

There should be no changes to the core behaviour of the app or any REST
calls.  For example, the /api/v1/categories call should return something
like this:
 {
   "userid": "dana",
   "groups": ["Hunny Bunnies", "Administrators"],
   "categories" : [
      "tmtrack",
      "work",
      "new category",
      "personal"
   ]
 }

Make this kind of change to all of the other REST calls.

Please add some relevant relevant tests and comprehensive documentation
for this change.  Modify the example curl command-line calls in the
existing documention to show how to send Authorization headers, as well
as the update output.

Please provide the necessary changes, and display all changed or added files in full.
</auth-and-authen-pt2>

<only-return-group-tasks>
Given an incoming GET to the tasks route, consider the various groups the
authenticated userid are in, and then find the unique set of userids in
all of those groups.

Change the tasks GET route to only return tasks that are associated with
the above defined set of userids.

No other behaviour in the application should change.

Modify relevant relevant tests as needed and add comprehensive documentation
for this change.

Write the necessary changes.
</only-return-group-tasks>

<delete-tasks>
Please add a REST method to allow individual tasks to be deleted.  A task
can only be deleted if the authorized userid is the same as the userid that
owns the task.

Please add and implement full test coverage for this change, and do not
change any other behaviour of the app.
</delete-tasks>

<dockerize>
The goal is to produce a docker image of this REST API that can be
deployed in production.

The image should use a relevant ubuntu base.
The image should contain everything needed to run this app,
including modern Python, Flask, testing.
The image can assume that a separate mongodb server is running on
localhost:27017.
The image should have a relevant suite of debugging and development
tools.

This change should update the README.md exactly explaining the steps
necessary to not only produce the docker image but also how to invoke
docker on the server side.

Please make no changes to the behaviour of the application.

Please create a uwsgi.ini configuration file that will correctly run
this app in a production environment.

When run as follows:
$ uwsgi --http-socket :5000 --plugin python3 --module wsgi:app

The following error is produced:

ModuleNotFoundError: No module named 'wsgi'
unable to load app 0 (mountpoint='') (callable not found or import error)

Please suggest changes to the command-line invocation and/or make 
necessary changes to the project so this can run under uwsgi.
</dockerize>


